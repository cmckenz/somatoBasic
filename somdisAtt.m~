% somdis.m
%
%        $Id:$ 
%      usage: somdisAtt()
%         by: justin gardner
%       date: 06/03/14
%    purpose: Somato discrimination task with attentional manipulation
%
%               Observer discriminates which of two temporal intervals
%               contains an increment over the base stimulus intensity.
%               Two piezo buzzers are used, only one of which has increment
%               applied. If attended condition, arrow indicates left (-1)/
%               right (1) buzzer has increment, else both equally likely.
%
function myscreen = somdisAtt(oldStairs)



% initalize the screen
myscreen = initScreen;

if oldStairs
    % get the last stimfile
    stimfile = getLastStimfile(myscreen,'stimfileNum=-1');
else
    stimfile = [];
end

% task parameters
task{1}.waitForBacktick = 0;
task{1}.seglen = [1 1.25 0.15 2 1]; %attention cue, stimulus, pause, response cue, feedback
task{1}.synchToVol = [0 0 0 0 0];
task{1}.getResponse = [0 1 1 0 0];
task{1}.parameter.pedestal = [0 0.125 0.25 0.5];
task{1}.parameter.distractPed = task{1}.parameter.pedestal;
task{1}.parameter.side = [-1 1];
task{1}.parameter.attention = [0 1];
task{1}.randVars.uniform.interval = [0 1];
task{1}.randVars.calculated.threshold = nan;
task{1}.randVars.calculated.correct = nan;
task{1}.randVars.calculated.responseInterval = nan;
task{1}.random = 1;
task{1}.numtrials = 250;





% initialize the task
for phaseNum = 1:length(task)
  [task{phaseNum} myscreen] = initTask(task{phaseNum},myscreen,@startSegmentCallback,@screenUpdateCallback,@responseCallback);
end

% init the stimulus
global stimulus;
myscreen = initStimulus('stimulus',myscreen);
stimulus = myInitStimulus(stimulus,myscreen,task,stimfile);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% run the eye calibration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%myscreen = eyeCalibDisp(myscreen);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main display loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
phaseNum = 1;
while (phaseNum <= length(task)) && ~myscreen.userHitEsc
  % update the task
  [task myscreen phaseNum] = updateTask(task,myscreen,phaseNum);
  % flip screen
  myscreen = tickScreen(myscreen,task);
end

% if we got here, we are at the end of the experiment
myscreen = endTask(myscreen,task);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function that gets called at the start of each segment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task myscreen] = startSegmentCallback(task, myscreen)

global stimulus;

if task.thistrial.thisseg == 1
  % time, so that we can preciesly set the two stimulation intervals
  timeNow = mglGetSecs;
  % pedestal stimulus strength
  ped = task.thistrial.pedestal;
  % delta 
  % update appropriate staircase
  pedInd = find(stimulus.pedestal==task.thistrial.pedestal);
  attInd = find(stimulus.attention == task.thistrial.attention);
  sideInd = find(stimulus.side== task.thistrial.side);
  
staircaseNum = (pedInd - 1)*(stimulus.numAtt*stimulus.numSide) + (attInd - 1)*stimulus.numSide + sideInd;

% stimulation level on distractor side?
distractPed = task.thistrial.distractPed;


  [stimulus.delta stimulus.s(staircaseNum)] = doStaircase('testValue',stimulus.s(staircaseNum));
  if (stimulus.delta < 0) stimulus.delta = 0;end
  % if this is ped == -1, then it means to give max difference randomly betwen sides
  if ped == -1
    ped = 0;
    stimulus.delta = 1;
  end
  % add the delta to the correct location
  if task.thistrial.side == -1
    stimulus.stimLeft = ped + stimulus.delta;
    stimulus.stimRight = distractPed;
  else
    stimulus.stimLeft = distractPed;
    stimulus.stimRight = ped + stimulus.delta;
  end
  
  % make sure we do not go over the maximum amplitude
  if stimulus.stimLeft > 1
      disp('WARNING: LEFT STIMULUS GREATER THAN 1 --> REDUCING STIMULUS INTENSITY');
      disp('L Stimulus of %.2f reduced to 1', stimulus.stimLeft);
      stimulus.stimLeft = 1;
  end
  if stimulus.stimRight > 1
      disp('WARNING: RIGHT STIMULUS GREATER THAN 1 --> REDUCING STIMULUS INTENSITY');
      disp('R Stimulus of %.2f reduced to 1', stimulus.stimRight);
      stimulus.stimRight = 1;
  end
  % multiply to get the actual voltage amplitude
  stimulus.stimLeft = stimulus.stimLeft * stimulus.maxStim;
  stimulus.stimRight = stimulus.stimRight * stimulus.maxStim;
  
  pulseWave = [stimulus.stimBase(1,:)*stimulus.stimLeft; stimulus.stimBase(2,:)*stimulus.stimRight];
  %if interval...
  if task.thistrial.interval == 0
      stimWave = [pulseWave stimulus.waitBase stimulus.stimBase];
  end
  
  if task.thistrial.interval == 1
      stimWave = [stimulus.stimBase stimulus.waitBase pulseWave];
  end
  
  
  stimulus.stimInd = mglInstallSound(stimWave);
  mglSetSound(stimulus.stimInd, 'deviceID', stimulus.deviceID);
end

if task.thistrial.thisseg == 2
  % set up the two stimulation period
  mglPlaySound(stimulus.stimInd);
  % display what we are doing
  disp(sprintf('Trial %i: %0.3f vs %0.3f (pedestal: %0.3f distractor: %0.3f delta: %0.3f side: %i interval: %i)',task.trialnum,stimulus.stimLeft,stimulus.stimRight,task.thistrial.pedestal,task.thistrial.distractPed, stimulus.delta,task.thistrial.side, task.thistrial.interval));
  % store delta
  task.thistrial.delta = stimulus.delta;
end

if task.thistrial.thisseg == 4
  % no response
  if isnan(task.thistrial.correct)
    task.thistrial.correct = false;
    % update appropriate staircase
  pedInd = find(stimulus.pedestal==task.thistrial.pedestal);
  attInd = find(stimulus.attention == task.thistrial.attention);
  sideInd = find(stimulus.side== task.thistrial.side);
  
  staircaseNum = (pedInd - 1)*(stimulus.numAtt*stimulus.numSide) + (attInd - 1)*stimulus.numSide + sideInd;

    stimulus.s(staircaseNum) = doStaircase('update',stimulus.s(staircaseNum),task.thistrial.correct);
    %  threshold = doStaircase('threshold',stimulus.s(staircaseNum));
    disp(sprintf('  No response. Delta: %0.2f',task.thistrial.delta));
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function that gets called to draw the stimulus each frame
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task myscreen] = screenUpdateCallback(task, myscreen)

global stimulus

% display attention cue
mglClearScreen;


if any(task.thistrial.thisseg == [1 2])
    
    if task.thistrial.attention == 0;
        leftCue = [1 1 1];
        rightCue = [1 1 1];
    end

if task.thistrial.attention == 1;
    if task.thistrial.side == -1;
        leftCue = [1 1 1];
        rightCue = [0 0 0];
    end
    if task.thistrial.side == 1;
        leftCue = [0 0 0];
        rightCue = [1 1 1];
    end
end

%where to draw the left arrow
  x = [  0.5  0.5    1   1  1.5   1       1];
  y = [-0.25 0.25 0.25 0.5    0  -0.5 -0.25];
  
  mglPolygon(-x, y, leftCue);
  mglPolygon(x, y, rightCue);
end

%3rd segment: blank period

if task.thistrial.thisseg == 4 %response cue... where was the stimulus?

%  mglFixationCross(1,1,[0 1 1]);
  if task.thistrial.side == -1
    leftCue = [1 1 1];
    rightCue = [0 0 0];
  end
  if task.thistrial.side == 1
    leftCue = [0 0 0];
    rightCue = [1 1 1];
  end
  
  %where to draw the left arrow
  x = [  0.5  0.5    1   1  1.5   1       1];
  y = [-0.25 0.25 0.25 0.5    0  -0.5 -0.25];
  
  mglPolygon(-x, y, leftCue);
  mglPolygon(x, y, rightCue);
end
  
  
%     % set colors only after the subject has responded
%   if ~isnan(task.thistrial.correct)
%     % display the chosen side in green or red contingent
%     % on whether subject was correct or not
%     if task.thistrial.responseSide == -1
%       mglFillOval(-4,0,[0.5 0.5],leftColor);
%     else
%       mglFillOval(-4,0,[0.5 0.5],[1 1 1]);
%     end
%     if task.thistrial.responseSide == 1
%       mglFillOval(4,0,[0.5 0.5],rightColor);
%     else
%       mglFillOval(4,0,[0.5 0.5],[1 1 1]);
%     end
%   else
%     mglFillOval(-4,0,[0.5 0.5],[1 1 1]);
%     mglFillOval(4,0,[0.5 0.5],[1 1 1]);
%   end

  

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    responseCallback    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function [task myscreen] = responseCallback(task,myscreen)

global stimulus

if task.thistrial.gotResponse < 1
  % caluclate response
  task.thistrial.responseSide = (task.thistrial.whichButton-1.5)*2;
  if task.thistrial.responseSide == task.thistrial.side
    task.thistrial.correct = true;
  else
    task.thistrial.correct = false;
  end
  
  % update appropriate staircase
  pedInd = find(stimulus.pedestal==task.thistrial.pedestal);
  attInd = find(stimulus.attention == task.thistrial.attention);
  sideInd = find(stimulus.side== task.thistrial.side);
  
  staircaseNum = (pedInd - 1)*(stimulus.numAtt*stimulus.numSide) + (attInd - 1)*stimulus.numSide + sideInd;
  
  stimulus.s(staircaseNum) = doStaircase('update',stimulus.s(staircaseNum),task.thistrial.correct);
%  threshold = doStaircase('threshold',stimulus.s(staircaseNum));
  disp(sprintf('  Response: %i Correct: %i Delta: %0.2f',task.thistrial.responseSide,task.thistrial.correct,task.thistrial.delta));
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function to init the stimulus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function stimulus = myInitStimulus(stimulus,myscreen,task,stimfile)

% set the maximum amplitude
stimulus.maxStim = 1;

%Basic stimulus waveform - Sine Wave, Amplitude = 1 (or = 2 peak to peak),
% Offset from beginning of file by 0.01s

startTime = 0.01;
eventLength = 0.5;
freq = 80;
sampleRate = 8192;

somEvents{1}(1) = startTime;
somEvents{1}(2) = eventLength;
somEvents{1}(3) = freq;
somEvents{1}(4) = 0;

somEvents{2}(1) = startTime;
somEvents{2}(2) = eventLength;
somEvents{2}(3) = freq;
somEvents{2}(4) = 1;

stimBase = somTrial(somEvents, sampleRate);

waitLength = 0.2;
waitBase = zeros(2, round(waitLength*sampleRate));

stimulus.stimBase = stimBase;
stimulus.waitBase = waitBase;

stimulus.deviceID = 2;

% determine pedestals and number of params so can init the staircases
params = getTaskParameters(myscreen,task);

pedestal = params.originalTaskParameter.pedestal;
numPedestal = length(pedestal);
stimulus.pedestal = pedestal;
stimulus.numPedestal = numPedestal;

side = params.originalTaskParameter.side;
numSides = length(side);
stimulus.side = side;
stimulus.numSide = numSides;

attention = params.originalTaskParameter.attention;
numAtt = length(attention);
stimulus.attention = attention;
stimulus.numAtt = numAtt;

%get the last stimfile if it's around...

% first time, initialize the staircases,
%need staircases for each pedestal, side, attention condition
numStairs = numPedestal * numSides * numAtt;

if isempty(stimfile)
  for iStaircase = 1:numStairs
    stimulus.s(iStaircase) = doStaircase('init','upDown','nup=1','ndown=2','initialThreshold=0.3','initialStepsize=0.1','nTrials=40','stepRule=levitt','minThreshold=0');
  end
% subsequent times, continue staircases from where we left off
else
  oldStimulus = stimfile.stimulus;
  % make sure all is the same NEED TO CHANGE THIS BIT HERE CAM
  if ~isfield(oldStimulus,'pedestal') || ~isfield(oldStimulus,'numPedestal') || ~isfield(oldStimulus,'s') || ~isequal(oldStimulus.pedestal,pedestal) || ~isequal(oldStimulus.numPedestal,numPedestal) || ~(length(oldStimulus.s) == numStairs)
    disp(sprintf('(somdis) !!! Previous stimfile has different conditions than this run, so restarting staircases !!!'));
    stimulus = myInitStimulus(stimulus,myscreen,task,[]);
    return
  end
  % if all is the same, then just reinit the staircases with the previous ones
  for iStaircase = 1:numStairs
    stimulus.s(iStaircase) = doStaircase('init',oldStimulus.s(iStaircase));
  end
end
